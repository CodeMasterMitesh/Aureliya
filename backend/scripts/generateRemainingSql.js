import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

// Generate a filtered SQL containing all CREATE TABLEs except legacy `contacts`
// and excluding temp/tmp tables, converting all engines to InnoDB and charset to utf8mb4.

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '..', '..')
const inputSqlPath = path.resolve(projectRoot, 'project.sql')
const outputDir = path.resolve(projectRoot, 'backend', 'sql')
const outputSqlPath = path.resolve(outputDir, 'remaining_no_contacts.sql')

function isTempish(name) {
  const n = name.toLowerCase()
  return (
    n.startsWith('temp') ||
    n.startsWith('tmp') ||
    n.includes('_temp') ||
    n.includes('_tmp') ||
    n.endsWith('_temp') ||
    n.endsWith('_tmp')
  )
}

function normalizeTableOptions(line) {
  // Replace ENGINE=MyISAM with ENGINE=InnoDB
  let out = line.replace(/ENGINE\s*=\s*MyISAM/gi, 'ENGINE=InnoDB')
  // Ensure DEFAULT CHARSET/ COLLATE are utf8mb4/utf8mb4_unicode_ci
  // Replace existing DEFAULT CHARSET=... [COLLATE=...] occurrence
  out = out.replace(/DEFAULT\s+CHARSET\s*=\s*[^\s;]+(\s+COLLATE\s*=\s*[^\s;]+)?/i, 'DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci')
  // Some lines may not have DEFAULT CHARSET; add before semicolon if missing
  if (!/DEFAULT\s+CHARSET/i.test(out)) {
    out = out.replace(/;\s*$/, ' DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;')
  }
  // Normalize utf8mb3/latin1 collations in other places too (defensive)
  out = out.replace(/utf8mb3/gi, 'utf8mb4').replace(/latin1_swedish_ci/gi, 'utf8mb4_unicode_ci').replace(/latin1/gi, 'utf8mb4')
  return out
}

function main() {
  if (!fs.existsSync(inputSqlPath)) {
    console.error('Input SQL not found at', inputSqlPath)
    process.exit(1)
  }
  const sql = fs.readFileSync(inputSqlPath, 'utf8')
  const lines = sql.split(/\r?\n/)

  let inCreate = false
  let skipBlock = false
  let currentTable = null
  const blocks = []
  let buf = []

  const startRegex = /^\s*CREATE\s+TABLE\s+IF\s+NOT\s+EXISTS\s+`([^`]+)`\s*\(/i
  const endRegex = /\)\s*ENGINE\s*=|\)\s*;\s*$/i

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]
    if (!inCreate) {
      const m = line.match(startRegex)
      if (m) {
        inCreate = true
        currentTable = m[1]
        // Decide skip
        const lower = currentTable.toLowerCase()
        const isLegacyContacts = /^contacts\d*$/i.test(currentTable)
        skipBlock = isLegacyContacts || isTempish(currentTable)
        buf = [line]
      } else {
        // ignore non-create lines
      }
    } else {
      buf.push(line)
      if (endRegex.test(line)) {
        // finalize block
        if (!skipBlock) {
          // Transform tail line for engine/charset
          const lastIdx = buf.length - 1
          buf[lastIdx] = normalizeTableOptions(buf[lastIdx])
          blocks.push(buf.join('\n'))
        }
        inCreate = false
        skipBlock = false
        currentTable = null
        buf = []
      }
    }
  }

  if (!fs.existsSync(outputDir)) fs.mkdirSync(outputDir, { recursive: true })
  const header = [
    '-- Generated by scripts/generateRemainingSql.js',
    `-- Source: ${path.relative(projectRoot, inputSqlPath)}`,
    '-- All tables except legacy `contacts` and temp/tmp tables.',
    'SET NAMES utf8mb4;\n',
  ].join('\n')

  fs.writeFileSync(outputSqlPath, header + '\n' + blocks.join('\n\n') + '\n')

  console.log('Wrote', outputSqlPath)
  console.log('Included tables:', blocks.length)
}

main()
